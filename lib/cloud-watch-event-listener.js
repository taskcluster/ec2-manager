const aws = require('aws-sdk');
const sqslib = require('sqs-simple');
const _ = require('lodash');
const events = require('events');
const assert = require('assert');
const {runAWSRequest} = require('./aws-request');
const log = require('./log');

function missingTags(obj) {
  let hasTag = false;
  if (obj.Tags) {
    for (let tag of obj.Tags) {
      if (tag.Key === 'Owner') {
        hasTag = true;
      }
    }
  }
  return !hasTag;
};

class CloudWatchEventListener extends events.EventEmitter {

  constructor({
    state,
    sqs,
    ec2,
    queueName = 'ec2-events',
    monitor,
    region,
    keyPrefix,
    runaws = runAWSRequest,
    tagger,
  }) {
    super();
    
    // Store the reference to the State we're using
    assert(typeof state === 'object');
    this.state = state;

    // Store the list of regions in which we're operating
    assert(typeof region === 'string');
    this.region = region;

    // Store some basic configuration values
    assert(typeof queueName === 'string');
    this.queueName = queueName;

    // We want to ensure that the keyPrefix is in the correct trailing colon
    // format passed in to avoid confusion, but we only internally use it as
    // the actual value without the colon, so we store that here
    assert(typeof keyPrefix === 'string');
    assert(keyPrefix[keyPrefix.length - 1] === ':');
    this.provisionerId = keyPrefix.slice(0, keyPrefix.length - 1);
    this.keyPrefix = keyPrefix;

    // Set up all the AWS clients that we'll possibly need
    assert(sqs);
    this.sqs = sqs;

    assert(ec2);
    this.ec2 = ec2;

    // We should always be using a
    assert(this.ec2.config.region === region);
    assert(this.sqs.config.region === region);

    // Store the reference to the monitor instance
    this.monitor = monitor.prefix('cloud-watch-events');

    assert(typeof tagger === 'object');
    this.tagger = tagger;

    this.queueUrl = undefined;

    this.sqsQueue = undefined;

    this.runaws = runaws;
  }

  async init() {
    this.queueUrl = await sqslib.getQueueUrl({sqs: this.sqs, queueName: this.queueName});

    this.sqsQueue = new sqslib.QueueListener({
      sqs: this.sqs,
      queueUrl: this.queueUrl,
      decodeMessage: false,
      maxNumberOfMessages: 10,
      sequential: true,
      handler: async msg => {
        let doodad = this.monitor.timeKeeper('message-handler-time');
        await this.__handler(msg);
        doodad.measure();
        this.monitor.count('handled-messages', 1);
      },
    });

    this.sqsQueue.on('error', (err, errType) => {
      // We probably want to bubble this up... maybe?
      //this.emit('error', err, errType);
      this.monitor.count('handler-errors', 1);
      log.error({err, errType}, 'SQS Handler Error');
      this.monitor.reportError(err, {errType});
    });
  }

  async __handler(msg) {
    let body = JSON.parse(msg);
    let region = body.region;
    let id = body.detail['instance-id'];
    let state = body.detail.state;
    // Not a great name, but this variable is the time that the CloudWatch
    // Event message was generated by the API, not the time at which we
    // received it
    let generated = new Date(body.time);

    let transaction = await this.state.beginTransaction();

    let dbResponse;

    try {
      dbResponse = await this.state.listInstances({region, id}, transaction);
    } catch (err) {
      await this.state.rollbackTransaction(transaction);
      throw err;
    }

    if (dbResponse.length > 1) {
      // for this case to be hit, there'd have to be a database schema problem
      await this.state.commitTransaction(transaction);
      throw new Error('verify database integrity!');
    } else if (dbResponse.length < 1) {
      await this.state.commitTransaction(transaction);
      log.info({id, region, state}, 'skipping messages for untracked instances');
    } else {
      // Now that we're only monitoring instances which are in the state
      // database, we no longer want to log cloudwatch events for unrelated
      // instances.  We do not do this as part of the ongoing transaction
      // because we want this logged regardless of whether that transaction
      // results in a commit or rollback
      try {
        await this.state.logCloudWatchEvent({region, id, state, generated});
      } catch (err) {
        // We don't want to block things, but let's bubble up the error for the
        // time being
        this.monitor.reportError(err);
      }
      
      dbResponse = dbResponse[0];
      // If there's a response from the database, we know that we already have
      // this information in the database.  We'll use this information to
      // figure out the immutable metadata

      let logInfo = {
        workerType: dbResponse.workerType,
        region: dbResponse.region,
        az: dbResponse.az,
        id: id,
        instanceType: dbResponse.instanceType,
        imageId: dbResponse.imageId,
        launched: dbResponse.launched,
        state,
        lastEvent: generated,
        metadataSource: 'db',
      };
      
      // Note that since we're now inserting instances directly into the
      // database now, we're always going to have a pending state in the db for
      // managed instances.  This means that most 'pending' state messages will
      // be ignored.
      if (dbResponse.lastEvent && dbResponse.lastEvent === generated) {
        log.warn("whoa!")
      } 

      if (dbResponse.lastEvent && dbResponse.lastEvent < generated) {
        try {
          if (state === 'pending' || state === 'running') {
            await this.state.updateInstanceState({
              region,
              id,
              state,
              lastEvent: generated
            }, transaction);
            log.info(logInfo, 'CloudWatch Event resulting in state update');
          } else {
            await this.state.removeInstance({region, id}, transaction);
            log.debug(logInfo, 'CloudWatch Event resulting in deletion');
          }
          await this.state.commitTransaction(transaction);
        } catch (err) {
          await this.state.rollbackTransaction(transaction);
          log.error(err, 'trying to update or remove instance');
          throw err;
        }
      } else {
        // While we didn't write anything, we did lock the row and claim a
        // client.  We should release those
        await this.state.commitTransaction(transaction);

        this.monitor.count('global.cwe-out-of-order.count', 1);
        this.monitor.count(`${region}.cwe-out-of-order.count`, 1);
        // We want to see how big our gaps in out of order delivery are.
        let delay = dbResponse.lastEvent - generated;
        this.monitor.measure('global.cwe-out-of-order.delay', delay);
        this.monitor.measure(`${region}.cwe-out-of-order.delay`, delay);
        log.info({
          region,
          id,
          state,
          delay,
          lastEvent: dbResponse.lastEvent,
          generated,
          currentDbState: dbResponse.state
        }, 'CloudWatch Event delivered out of order');
      }
    }
  }

  start() {
    assert(this.sqsQueue);
    this.sqsQueue.start();
  }
  
  stop() {
    assert(this.sqsQueue);
    this.sqsQueue.stop();
  }
}

class DeadCloudWatchEventListener extends events.EventEmitter {

  constructor({
    sqs,
    queueName = 'ec2-events',
    monitor,
    region,
  }) {
    super();

    // Store the list of regions in which we're operating
    assert(typeof region === 'string');
    this.region = region;

    // Store some basic configuration values
    assert(typeof queueName === 'string');
    this.queueName = queueName;

    // Set up all the AWS clients that we'll possibly need
    assert(sqs);
    this.sqs = sqs;

    assert(this.sqs.config.region === region);

    // Store the reference to the monitor instance
    this.monitor = monitor.prefix('cloud-watch-events');

    this.queueUrl = undefined;

    this.sqsQueue = undefined;
  }

  async init() {
    this.queueUrl = await sqslib.getQueueUrl({sqs: this.sqs, queueName: this.queueName});

    this.sqsQueue = new sqslib.QueueListener({
      sqs: this.sqs,
      queueUrl: this.queueUrl,
      decodeMessage: false,
      maxNumberOfMessages: 10,
      maxReceiveCount: 20,
      handler: async msg => {
        await this.__handler(msg);
      },
    });

    this.sqsQueue.on('error', (err, errType) => {
      // We probably want to bubble this up... maybe?
      //this.emit('error', err, errType);
      log.error({err, errType}, 'SQS Handler Error');
    });
  }

  // TODO: Maybe what we should do is store these instance ids in a table and
  // poll them to see when they do become available and insert them into the
  // database *then*
  async __handler(msg) {
    let errorMsg = [
      'UNTRACKED INSTANCE\n\n',
      'A CloudWatch Event message has failed.  This is likely because the',
      'EC2 API call to DescribeInstances did not return information.  While',
      'we do retry this a number of times, we eventually give up.  This instance',
      'should probably be killed or else deleted.',
    ].join(' ');

    errorMsg += '\nFailing message follows:\n\n';
    errorMsg += msg;

    this.monitor.reportError(new Error(errorMsg), 'info');
  }

  start() {
    assert(this.sqsQueue);
    this.sqsQueue.start();
  }
  
  stop() {
    assert(this.sqsQueue);
    this.sqsQueue.stop();
  }
}

async function initCloudWatchEventListener(opts) {
  let obj = new CloudWatchEventListener(opts);
  await obj.init();
  return obj;
}

async function initDeadCloudWatchEventListener(opts) {
  let obj = new DeadCloudWatchEventListener(opts);
  await obj.init();
  return obj;
}

module.exports = {
  initCloudWatchEventListener,
  initDeadCloudWatchEventListener,
  CloudWatchEventListener,
};
